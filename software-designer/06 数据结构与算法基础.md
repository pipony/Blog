# 06 数据结构与算法基础

![image-20220503153056928](http://cdn.huangxindi.com/img/image-20220503153056928.png)

## 数组

考点：存储地址计算

![image-20220503153232866](http://cdn.huangxindi.com/img/image-20220503153232866.png)

## 稀疏矩阵

![image-20220503153602838](http://cdn.huangxindi.com/img/image-20220503153602838.png)

矩阵坐标转换到数组坐标的解题技巧：带入特殊值

## 数据结构的定义

概念：计算机存储和组织数据的方式

逻辑结构划分

- 线性结构
- 非线性结构
  - 树 
  - 图

## 线性表

分类

- 顺序表（一维数组形式）

- 链表（节点包含数据与指针）

  - 单链表
  - 循环链表
  - 双向链表

- 队列（先进先出）

  - 循环队列

    ![image-20220503155120397](http://cdn.huangxindi.com/img/image-20220503155120397.png)

- 栈（先进后出）

链表的基本操作（删除和插入节点）

顺序存储和链式存储对比：

![image-20220503154523426](http://cdn.huangxindi.com/img/image-20220503154523426.png)

## 广义表

概念：线性表的推广，以递归的方式进行定义

广度（最外层括号包含的元素个数）、深度（包含括号的重数）

表头head（最外括号的第一个元素）、表尾tail（除去表头的其他所有部分）

![image-20220503160909846](http://cdn.huangxindi.com/img/image-20220503160909846.png)

## 树与二叉树

![image-20220503160933287](http://cdn.huangxindi.com/img/image-20220503160933287.png)

结点的度：孩子数

数的度：所有结点度数最高的度

内部节点：非头节点和叶子节点

深度：最大的层数

### 特殊二叉树

- 满二叉树
- 完全二叉树（除最后一层，上面层都满；且最后一层从左到右没有**中间缺失**的情况）

![image-20220503161436409](http://cdn.huangxindi.com/img/image-20220503161436409.png)

### 二叉树遍历

- 前、中、后序遍历：差别在根节点前、中、后时候被访问

- 层次遍历

### 反向构造二叉树

例题：

![image-20220503162440549](http://cdn.huangxindi.com/img/image-20220503162440549.png)

### 树转二叉树

原则：

- 孩子结点 -> 左子树结点
- 兄弟结点 -> 右孩子结点

![image-20220503162707664](http://cdn.huangxindi.com/img/image-20220503162707664.png)

除了挨个用【原则】分析，还可以用连线法：如上图的虚线图所示。将兄弟结点连起来，并将第一个孩子以外的孩子结点的连线去掉，然后旋转，得到最终的二叉树

### 查找二叉树（二叉排序树）

特点：

- 左孩子小于根
- 右孩子大于根
- 极大提高查找速度

操作：插入和删除结点

![image-20220503163239625](http://cdn.huangxindi.com/img/image-20220503163239625.png)

### 最优二叉树（哈夫曼树）

哈夫曼树：用于无损压缩

基本概念：

- 树的路径长度
- 权（每个结点的数值，一般表示出现的频度）
- 带权路径长度
- 树的带权路径长度（树的代价）

构造哈夫曼树：**即构造带权路径长度最小的树**

例题：

![image-20220503163738267](http://cdn.huangxindi.com/img/image-20220503163738267.png)

求解树的带权路径长度：**将所有叶子结点的带权路径长度相加**

## 线索二叉树

why：很多结点的左右指针是空的，可以利用这些空闲指针，来方便遍历

- 前序线索二叉树
- 中序线索二叉树
- 后序线索二叉树

构造线索二叉树：左右线索指针指向的是x序排列的前/后面的结点

## 平衡二叉树

定义：

- 左右子树深度相差不超过1
- 每个结点的平衡度（左子树深度-右子树深度）只能为-1，0，1

非平衡二叉树 -> 平衡二叉树

## 图

图与树最大的区别：**树没有环路**

分类：

- 有向图
- 无向图
- 完全图（可连的边都连了）

### 存储

- 邻接矩阵

![image-20220503165639983](http://cdn.huangxindi.com/img/image-20220503165639983.png)

- 邻接表

![image-20220503165817778](http://cdn.huangxindi.com/img/image-20220503165817778.png)

### 图的遍历

- 深度遍历
- 广度遍历

根据邻接表进行遍历：广度是一个结点所连的线走到底，深度是连续试探第一个

### 拓扑排序

表示活动之间开始的**先后关系**

![image-20220503170224108](http://cdn.huangxindi.com/img/image-20220503170224108.png)

执行完把连线去掉，继续分析

### 图的最小生成树

使得留下来的边（n-1条，n为节点数）构成树（注意不能有环），权值总和最小

#### 普利姆算法

![image-20220503170607893](http://cdn.huangxindi.com/img/image-20220503170607893.png)

分析：画图时实时将结点分成两个阵营，寻找到另一个阵营的最短边

#### 克鲁斯卡尔算法

依次选择权最小的边，注意不要构成环。连接所有结点后，即生成结束

## 算法基础

### 算法的特性

![image-20220503170847056](http://cdn.huangxindi.com/img/image-20220503170847056.png)

### 算法的复杂度

![image-20220503171033563](http://cdn.huangxindi.com/img/image-20220503171033563.png)

### 顺序查找和二分查找

#### 顺序查找

![image-20220503171742095](http://cdn.huangxindi.com/img/image-20220503171742095.png)

#### 二分查找

![image-20220503171839069](http://cdn.huangxindi.com/img/image-20220503171839069.png)

前提：查找内容本身是有序排序的

![image-20220503172118001](http://cdn.huangxindi.com/img/image-20220503172118001.png)

![image-20220503172151529](http://cdn.huangxindi.com/img/image-20220503172151529.png)

### 散列表

![image-20220503172237781](http://cdn.huangxindi.com/img/image-20220503172237781.png)

冲突解决：

- 线性探测法（往后顺序查找第一个空的）
- 伪随机数法
- 再散列法

### 排序（重要）

![image-20220503172611622](http://cdn.huangxindi.com/img/image-20220503172611622.png)

稳定性：**值相同的数**，排序后，顺序是否不变

内/外排序：前者只在内存中，后者用到外存

#### 直接插入排序

![image-20220503173036376](http://cdn.huangxindi.com/img/image-20220503173036376.png)

#### 希尔排序

是直接插入排序的一种，但更复杂。

好处是：经过前几轮的组内直接插入排序，序列已基本有序。到最后一轮的全组直接插入排序时，调整顺序的次数会更少。

![image-20220503173355864](http://cdn.huangxindi.com/img/image-20220503173355864.png)

#### 直接选择排序

![image-20220503173454649](http://cdn.huangxindi.com/img/image-20220503173454649.png)

#### 堆排序

堆的概念

![image-20220503173755500](http://cdn.huangxindi.com/img/image-20220503173755500.png)

堆排列概念和步骤：

![image-20220503173843849](http://cdn.huangxindi.com/img/image-20220503173843849.png)

**初建堆过程：**

- 顺次将结点数组构成完全二叉树
- 调整为堆（从最后一个非叶子结点开始，而后分析最后第二个）
- 注意，有的结点调整需要向下继续调整

![image-20220503174316966](http://cdn.huangxindi.com/img/image-20220503174316966.png)

**重新建堆过程：**

- 把根结点取走
- 把堆的最后一个结点放到根结点
- 从根节点开始与子节点对比，一直往下

![image-20220503174646194](http://cdn.huangxindi.com/img/image-20220503174646194.png)

所以，诸如从大量数据中求前10小的元素，比较有优势

#### 冒泡排序

![image-20220503175039139](http://cdn.huangxindi.com/img/image-20220503175039139.png)

#### 快速排序

![image-20220503175310879](http://cdn.huangxindi.com/img/image-20220503175310879.png)

分析：

- 分治法
- 与基准比较

#### 归并排序

![image-20220503175501777](http://cdn.huangxindi.com/img/image-20220503175501777.png)

一般是两两合并

#### 基数排序

![image-20220503175728873](http://cdn.huangxindi.com/img/image-20220503175728873.png)

基数和关键字的分解有关

#### 排序算法分析（常考）

![image-20220503175936970](http://cdn.huangxindi.com/img/image-20220503175936970.png)